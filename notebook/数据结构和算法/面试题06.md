# 面试题-网络专题

# TCP/IP部分

## 什么是TCP/IP

TCP/IP 是一类协议系统，它是用于网络通信的一套协议集合．

通常分为四层：网络接口层，网络层，传输层，应用层

### 网络接口层

- 与osi参考模型中的物理层，数据链路层相对应，主要指物理层次的一些接口

### 网络层

- 与osi参考模型中的网络层相对应，功能包括寻址和路由选择
- 包括IP协议 ARP协议 ICMP协议 IGMP协议

**IP协议**

IP协议的版本 : IPv4 （32位地址）IPv6 （128位地址）

注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。

IPv4相关：

- 一个 32 位的地址,这个地址通常分成 4 段，每 8 个二进制为一段，为了方便阅读，通常会将每段都转换为十进制来显示，如192.168.0.1

- IP 地址分为两个部分：网络 ID 主机 ID
- A 类地址：IP 地址的前 8 位代表网络 ID ，后 24 位代表主机 ID。 化为十进制也就是 0-127 二进制开头 0
- B 类地址：IP 地址的前 16 位代表网络 ID ，后 16 位代表主机 ID。化为十进制也就是 128-191 二进制开头 10
- C 类地址：IP 地址的前 24 位代表网络 ID ，后 8 位代表主机 ID。 化为十进制也就是 192-223  二进制开头 110
- 大于223的还有DE类地址，并不常用

- 全是 0 的主机 ID 代表网络本身，比如说 IP 地址为 130.100.0.0 指的是网络 ID 为130.100 的 B 类地址。
- 全是 1 的主机 ID 代表广播，是用于向该网络中的全部主机发消息的。 IP 地址为 130.100.255.255 就是网络 ID 为 130.100 网络的广播地址（二进制 IP 地址中全是 1 ，转换为十进制就是 255 ）
- 以十进制 127 开头的地址都是环回地址。目的地址是环回地址的消息，其实是由本地发送和接收的。主要是用于测试 TCP/IP 软件是否正常工作。我们用 ping 功能的时候，一般用的环回地址是 127.0.0.1

**地址解析协议ARP**

- ARP 的作用就是把 IP 地址映射为物理地址，而与之相反的 RARP（逆向 ARP）就是将物理地址映射为 IP 地址。

子网掩码的概念：

- 对于A类和B类地址来说，每个网络下的主机数量过多，那么网络传输就会变得很低效，为了解决这个问题，子网掩码随之出现
- 计算方式
  - 根据子网数：
    - （1）将给定的子网数转为2进制 如 27 => 11011 
    - （2）因为二进制位 5 位数所以 N = 5
    - （3）得到ip地址类型 如 B类 则将 255.255.0.0 转为  二进制， 将二进制的前N位（这里为5） 转为 1,之后转为10进制后得到的值就是子网掩码值
  - 根据主机数
    - 与根据子网数类似，也是先将主机数转为二进制 得到N,用N带入ip地址，求出子网掩码

**网络控制报文协议（ICMP协议）**

IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。

当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。

**ping可以说是ICMP的最著名的应用**，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。

ICMP另一个应用就是 **tracert（跟踪路由）他是 trace router的缩写**

它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，tracert（就拿到了所有的路由器IP。

### 传输层（TCP,UDP详解）

两种到达目标网络的协议，TCP(传输控制协议) UDP(用户数据报协议)

TCP:提供了完善的错误控制和流量控制,会建立连接通道，数据大小无限制
速度慢，但是可靠性高

UDP:只提供了基本的错误检测,会把数据打包，数据大小有限制（64k）,不建立连接，速度快，但可靠性低

![面试17](G:\笔记\数据结构和算法图片\面试17.png)

**全双工**是指发送的同时可以接收

**面向报文**是指应用层交给UDP多长的报文，UDP就会发送多长的，所以报文必须长度合适，也就是上文所说的数据大小有限制

**面向字节流**就是指如果应用层交给TCP的数据过长，就可以分块发送，所以大小无限制

**TCP流量控制**

如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。

利用**滑动窗口机制**可以很方便地在TCP连接上实现对发送方的流量控制。

设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。

![面试20](G:\笔记\数据结构和算法图片\面试20.png)

从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。



TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。



**TCP拥塞控制**

即 慢开始 拥塞避免 快重传 快恢复

1.**慢开始和拥塞避免**

发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。

发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

**慢开始算法**：

当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。
因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。

通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。

![面试21](G:\笔记\数据结构和算法图片\面试21.png)

每经过一个传输轮次，拥塞窗口 cwnd 就加倍。**一个传输轮次所经历的时间其实就是往返时间RTT。**不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。



另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。

为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh（慢启动门阀）状态变量。慢开始门限ssthresh的用法如下：

- 当 cwnd < ssthresh 时，使用上述的慢开始算法。
- 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
- 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法

**拥塞避免**

让拥塞窗口cwnd缓慢地增大，即每经过**一个往返时间RTT**就把发送方的**拥塞窗口cwnd加1，而不是加倍**。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

![面试22](G:\笔记\数据结构和算法图片\面试22.png)

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。

这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。

下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。

![面试23](G:\笔记\数据结构和算法图片\面试23.png)

**快重传和快恢复**

**快重传**

快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。

![面试24](G:\笔记\数据结构和算法图片\面试24.png)

接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。



显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。

但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。

**快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。**

由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。



**快恢复**

与快重传配合使用的还有快恢复算法，其过程有以下两个要点：

- 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。
- 与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。


![面试25](G:\笔记\数据结构和算法图片\面试25.png)

### 应用层

运行在TCP协议上的协议

- HTTP 超文本传输协议
- HTTPS
- FTP 文件传输协议
- POP3 邮局协议 （支持离线邮件处理）
- SMTP 简单邮件传输协议
- Telnet 远程终端协议 ，（可以用本地主机，操作远程服务器）
- SSH 安全外壳协议  为远程会话提供更高的安全性
- SFTP

**ftp和sftp的区别**

ftp是一个文件传输服务，设计它的目的就是为了传输文件。它有独立的守护进程，使用**20，21两个端口**，20是数据链路的端口，21是控制链路的端。

sftp也是用来传输文件的，但它的**传输是加密**的，是ssh服务的一部分，没有单独的守护进程，是**ssh服务**的一部分，可以看做是ssh服务文件传输方案。**和ssh一样，使用22端口**，安全的同时**效率相比ftp要低**

**运行在UDP协议上的协议**

- TFTP文件传输协议 使用端口号 69
- NTP 网络时间协议
- DHCP 动态主机配置协议 （能够自动分配 ip地址 子网掩码）

**其他**

**DNS 域名系统** （将域名和IP地址相互映射的一个分布式数据库）

DNS同时占用tcp和udp的53端口，

它大多数时使用UDP协议，如域名解析，

少数使用TCP协议，如：辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。

- 域名是指  例：`www.abc.com`

## 输入URL后发生了什么

### 什么是URL

统一资源定位符

` scheme: // host.domain:port / path / filename ? abc = 123 # 456789 `

scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，
               其中最常见的类型是 http，而 https 则是进行加密的网络传输。
host         - 定义域主机（http 的默认主机是 www）
domain       - 定义因特网域名，比如 baidu.com
port         - 定义主机上的端口号（http 的默认端口号是 80）
path         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
filename     - 定义文档/资源的名称
query        - 即查询参数
fragment     - 即 # 后的hash值，一般用来定位到某个位置

**关于URI**

- 统一资源标志符：在某一规则下能把一个资源独一无二地标识出来
- URL就是URI的一种体现，它是URI的子集，可以理解为它是定位方式实现的URI

### 输入URL后进行的流程

- DNS 解析:将域名解析成 IP 地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面 - 
  - 关于这部分可以参考 异步与浏览器渲染文件中的
    - 浏览器中的进程和渲染流程部分的内容
- 断开连接：TCP 四次挥手

### 三次握手详解

1、第一次握手：客户端给服务器发送一个 SYN 报文。

2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。

3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。

4、服务器收到 ACK 报文之后，三次握手建立完成。

为什么一定是三次

![面试18](G:\笔记\数据结构和算法图片\面试18.png)

刚开始客户端处于 closed 的状态，服务端处于被动打开的 listen 状态。然后

1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 Seq。此时客户端处于 SYN_Send 状态。
2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 Seq，同时会把客户端的 Seq + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。
3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 Seq + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。
4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。

三次握手的作用 

-  确认双方的接受能力、发送能力是否正常 
-  指定自己的初始化序列号，为后面的可靠传送做准备 
-  如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。 

Seq是动态生成的

什么是半连接队列 

- 服务器第一次接收SYN之后，处于SYN-RCVD状态，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列
- **全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

关于重传：

- SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

三次握手可以携带数据吗

- 第三次可以，因为这时客户端处于esablihed状态，并且已经知道服务器接收，发送能力均正常

### 四次挥手

![面试19](G:\笔记\数据结构和算法图片\面试19.png)

==刚开始双方都处于 established 状态，假如是客户端先发起关闭请求，则：==

==补充说明：这里的客户端服务端实际上没有明确概念，可以理解为主机1和主机2，为了方便理解我们将其分为客户端，服务端==

1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT_1状态。
2、第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态,客户端接收报文处于FIN_WAIT_2状态
3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。



**为什么有四次挥手**

TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。



关于**TIME_WAIT**状态，要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因有两点：

**一是**要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

**二是** 如果客户端（主机1）再次发起新连接到服务器（主机2），有可能会出现端口号和老端口相同的情况，如果前一次连接的某些数据仍然滞留在网络中，就有可能会发生新老数据混淆情况。

至于 TIME_WAIT 持续的时间一般是**2MSL**(MSL是指报文段最大生存时间)。如果过了这个计时没有再次收到 FIN 报文，则代表对方成功接收 ACK 报文，此时处于 CLOSED 状态。

# HTTP/HTTPS部分

![面试26](G:\笔记\数据结构和算法图片\面试26.png)

## HTTP报文结构

- 起始行
  - 请求状态行： 请求方式 请求地址 协议及版本号
  - 响应状态行： 协议和版本号 返回的状态码  返回的状态（如OK）
- 头部
  - 通用的：
    - Connection: 客户端和服务端通信时，是否持久连接
    -  Content-Length:内容长度;
    - Content-Type:指定资源的MIME类型
  - 请求头部信息
    -    HOST:指定服务器域名和端口 ;     
    -    Accept: 接收的内容类型
    - User-Agent客户端相关信息;  
    - Accept-Encoding： 会将客户端能够理解的内容编码方式； Accept-Language:浏览器可接受的语言
    - `Accept-Charset` :可接受的字符集； `Cookie` : 携带的cookie信息；  Cache-Control`  ：缓存机制
    - 跨域相关的头见 面试题01-跨域访问的方案
  - 响应头部信息
    - Server:服务器 相关信息 ；`Date`: 响应报文的时间；` Transfer-Encoding`: 传输编码的方法
    - `Set-Cookie`: 设置Cookie ； `ETag` 资源的表示符，用于比对资源，查看是否有更新
    - `Location` 首部指定的是需要将页面重新定向至的地址 ;`Expires`: 有效时间
    - 跨域相关的头见 面试题01-跨域访问的方案
- 空行
- 实体
  - 请求体
  - 响应体

## 关于URL

- 见上文  什么是URL

## 状态码

- 见面试题03- 关于状态码

## HTTPS

### HTTP与HTTPS的区别

HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密

HTTP 的端口号是 80，HTTPS 是 443

HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费

HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

### 加密方式的解读

- 单纯使用对称秘钥（加密和解密使用同一个秘钥）： 弊端是可能会被中间人拦截，从而对传输的信息进行窥视和篡改

- 使用RSA（非对称加密）：一个私钥，一个公钥，只有对应的公钥私钥才能相互解密。缺点是速度非常的慢

- 使用对称加密+非对称加密： 由于使用对称密钥的好处是速度比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解。所以可以通过使用 RSA 的方法将加密算法的对称密钥发送过去，之后就可以使用使用这个密钥，利用对称密钥来通信了。
  - 该方式的问题：安全是没有保障的，中间人可以拦截到 公钥，就可以对拦截到的公钥进行篡改（比如换第一次通讯时，接收方也不知道公钥是，所以如果中间人换一个新的公钥，就会出现安全问题）
  - 解决方法：通过在原始信息上，添加数字签名，形成数字证书，之后通过对数字证书进行解密，对比后，即可判断是否被人篡改过
- 也就是通过： 对称加密 + 非对称加密 + 数字证书 进行加密

## HTTP

### HTTP的特点

- 灵活可扩展: 一是语义上的自由，只规定了基本格式； 二是传输形式的多样性，文本，图片，视频都可以传输
- 可靠传输： 因为它基于TCP/IP
- 请求-应答： 也就是一收一发，有来有回
- 无状态： 状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。

### HTTP的缺点：

- **无状态**： 在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。

  但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

- **明文传输**: 即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。

- **队头阻塞问题**： 当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态

### HTTP 1.1

- 解决了HTTP1.0队头阻塞问题： 

  - 并发连接： 对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。

  - 域名分片： 一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。

    比如 content1.sanyuan.com 、content2.sanyuan.com。

    这样一个`sanyuan.com`域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

- **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

- **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

- **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）

- **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

### HTTP /2

- 头部压缩： 使用HPACK 算法 ，在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把**索引**(比如0，1，2，...)传给对方即可，对方拿到索引查表就行了。
- 多路复用： 
  -  HTTP 队头阻塞的问题，我们用并发连接和域名分片的方式来解决这个问题，但这并没有真正从 HTTP 本身的层面解决问题，只是增加了 TCP 连接，分摊风险而已。而且这么做也有弊端，多条 TCP 连接会竞争有限的带宽，让真正优先级高的请求不能优先处理。
  - 实现原理： HTTP/2 把报文全部换成二进制格式，全部传输`01`串，方便了机器的解析，分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。
  - 这种二进制帧的**双向传输的序列**，也叫做`流`(Stream)。HTTP/2 用`流`来在一个 TCP 连接上来进行多个数据帧的通信，这就是**多路复用**的概念。
  - 注意乱序指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的**请求报文**和**响应报文**。在二进制帧还有一些额外的字段，实现了**优先级**和**流量控制**等功能
- 设置请求优先级： 通过二进制帧实现
- 服务器推送：  HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。

## websocket

### 特点

- WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。

  WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

- 建立在 TCP 协议之上

- 支持双向通信，实时性更强 ； 
- 可以发送文本，也可以发送二进制数据。
- 较小的控制开销，头部信息较少，不像HTTP协议一样，每次通信都携带完整的头部
- 支持扩展，可以实现自定义的子协议
- 与 HTTP 协议有着良好的兼容性。默认端口也是80和443
- 没有同源限制
- 协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

### 客户端API

```js
// 1.WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。
var ws = new WebSocket('ws://localhost:8080');
 
// 2. webSocket.readyState 属性返回实例对象的当前状态，共有四种。
// CONNECTING：值为0，表示正在连接。
// OPEN：值为1，表示连接成功，可以通信了。
// CLOSING：值为2，表示连接正在关闭。
// CLOSED：值为3，表示连接已经关闭，或者打开连接失败。

switch (ws.readyState) {
  case WebSocket.CONNECTING:  // 0
    // do something
    break;
  case WebSocket.OPEN:   // 1
    // do something
    break;
  case WebSocket.CLOSING:    // 2
    // do something
    break;
  case WebSocket.CLOSED:   // 3
    // do something
    break;
  default:
    // this never happens
    break;
}

//3. webSocket.onopen  实例对象的onopen属性 用于指定连接成功后的回调函数。
ws.onopen = function () {
  ws.send('Hello Server!');
}
    // 如果要指定多个回调函数，可以使用addEventListener方法。
ws.addEventListener('open', function (event) {
  ws.send('Hello Server!');
})


// 4. webSocket.onclose 实例对象的onclose属性 用于指定连接关闭后的回调函数。
ws.onclose = function(event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
};

ws.addEventListener("close", function(event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
});


//5. webSocket.onmessage 实例对象的onmessage属性用于指定收到服务器数据后的回调函数。
ws.onmessage = function(event) {
  var data = event.data;
  // 处理数据
};

ws.addEventListener("message", function(event) {
  var data = event.data;
  // 处理数据
});

// 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。
ws.onmessage = function(event){
  if(typeof event.data === String) {
    console.log("Received data string");
  }

  if(event.data instanceof ArrayBuffer){
    var buffer = event.data;
    console.log("Received arraybuffer");
  }
}

// 6. webSocket.send() 实例对象的send()方法用于向服务器发送数据。
// 发送文本
ws.send('your message')
// 发送Blob对象
var file = document
  .querySelector('input[type="file"]')
  .files[0];
ws.send(file)
// 发送ArrayBuffer
   // Sending canvas ImageData as ArrayBuffer
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i < img.data.length; i++) {
  binary[i] = img.data[i];
}
ws.send(binary.buffer);

// 7. webSocket.bufferedAmount 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束

var data = new ArrayBuffer(10000000);
socket.send(data);

if (socket.bufferedAmount === 0) {
  // 发送完毕
} else {
  // 发送还没结束
}

// 8.  webSocket.onerror 实例对象的onerror属性，用于指定报错时的回调函数。

socket.onerror = function(event) {
  // handle error event
};

socket.addEventListener("error", function(event) {
  // handle error event
});
```

### 服务端实现 

如： socket.IO