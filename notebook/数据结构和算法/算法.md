# 算法

## 算法(Algorithm)的理解

- 解决问题的办法，步骤逻辑，数据结构的实现离不开算法
- 是一个有限指令集，每条指令的描述不依赖于语言
- 接受一些输入，个别情况下不需要输入
- 产生输出
- 在一定有限步骤后终止

## 大O表示法

- 算法的速度指的并非时间，而是操作数的增速。讨论算法的速度时，我们通常说的是，随着时间的增加，其运行时间将以什么样的速度增加
- 大O表示法，可以简单的理解为：时间与其操作数的关系

![算法01](G:\笔记\数据结构和算法图片\算法01.png)

### 常见的大O运行时间

- O（log~(n)~） 也叫对数时间： 二分查找
- O（n） 也叫线性时间：简单查找
- O（nlog~(n)~） ： 快速排序
- O（n^2^）：选择排序
- O（n!）:  旅行商问题

### 推导过程中大O表达式的简化

- 用1取代所有常量  897 -》 1
- 多项式只保留最高次项    a^2^ +1  -》   a^2^ 
- 最高次项如果不为1 且有常数相乘则去掉常数   2a^2^  -》  a^2^ 

## 冒泡排序

### 思路

- 对未排序的元素，从头到尾依次比较相邻两个元素大小关系，如果左边大（或者小），则交换位置，当换到最右边时，继续从左边开始，这次换到倒数第二个位置即可，如此往复，直到排序完成

### 代码实现

```javascript
function BubbleSort(arr) {
  //解构得到arr的length属性
  const {length} = arr
  //外层循环为比较轮数
  for (let i=0; i<length-1; i++) {
    //内层循环为比较次数 一次内循环结束，就会有一个大值排到后面
    // -i是避免对已经排序过的数字重复比较，减少比较次数，提高效率
    for (let j=0; j<length-1-i; j++) {
      if (arr[j] > arr[j+1]) {
        [arr[j],arr[j+1]] = [arr[j+1],arr[j]]
      }
    }
  }
  return arr
}
```

### 时间复杂度的计算

随机使用一组数字，可以得到如果所示的排序次数

![算法02](G:\笔记\数据结构和算法图片\算法02.png)

那么可以得出如果有n个数字，排序总次数为，(n-1+n-2+ ·····1) =  n(n-1) / 2

又∵ n(n-1) / 2 -> n^2^ - n    ->   n^2^ 所以 冒泡排序的时间复杂度为 O(n^2^)



## 选择排序

### 思路

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕

![算法01](G:\笔记\数据结构和算法图片\算法01.gif)

- 选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。

### 代码实现

```javascript
function selectionSort(arr) {
  const {length} = arr
  //从0开始循环 一直循环到length-2的位置为止
  for (let i=0; i<length-1; i++) {
    //定义一个min用于记录最小的位置
    let min = i
    // i+1 是为了排除已经排序过得最小值
    for (let j= i+1; j<length; j++) {
      // 将其余位置进行依次比较，如果最小值发生变化则记录下来
      if (arr[min] > arr[j]) {
        min = j
      }
    }
    //将比较后的最小值与开头的位置i进行交换 之后继续循环
    [arr[i],arr[min]] = [arr[min],arr[i]]
  }
  return arr
}
```

### 选择排序的效率



- 比较次数相同，所以时间复杂度相同都是O(n^2^)

### 选择排序与冒泡排序的区别

- 两者的时间复杂度相同都是O(n^2^)
- 但通常来说，选择排序的速度更快些
- 两者的区别主要体现在交换次数上：
  - 两者每一轮都是通过比较将最大或最小值放到指定位置，就这一点来说，比较次数是相同的
  - 然而在比较过程中，冒泡排序是，两两比较，一旦符合要求就交换。选择排序是，只记下最小或最大值的位置，在最后才交换，它的交换次数更少，所以相对更快些

## 插入排序

### 思路

- 构建有序的序列。
-  对于未排序的数据，在已排序数据中，从后向前扫描，找到相应位置插入

![算法02](G:\笔记\数据结构和算法图片\算法02.gif)

### 代码实现

```javascript
function insertionSort(arr) {
  //解构取出数组长度
  const {length} = arr
  //遍历除第0个元素外的所有元素
  for (let i=1; i<length; i++) {
    //因为while循环需要从后向前比较，所以需要一个可变的索引值
    //保存当前遍历元素的索引到j
    let j = i
    //因为之后arr[i]得值可能发生改变
    //所以保存当前元素索引对应的值到temp
    const temp = arr[i]
    //将temp与它前面的已排序序列进行比较 如果符合大于temp 且j>0时
    while (arr[j-1] > temp && j>0) {
      //将前值赋予后值
      arr[j] = arr[j-1]
      //通过自减j的值，改变对比的值
      j--
    }
    //最后将temp中保存的值 赋予对应的空位
    arr[j] = temp
  }
  return arr
}
```

### 插入排序的效率

最坏时间复杂度：每一次都扫描到最前面才找到合适位置

 1+2+3···n-1 = n(n-1) / 2       ==O(n^2^)==

平均时间复杂度：一般来说扫描到一半即可找到合适位置，虽然复杂度没有变化，但由于多除了2实际上是有效率提升的

 1+2+3···n-1 = n(n-1) / 2/2 =   n(n-1) / 4      ==O(n^2^)==

最优时间复杂度：数据原本就有序每次直接就可以找到   ==O(n)==

## 算法稳定性

### 什么是算法稳定性

- 排序前后两个相等的数相对位置不变，则算法稳定
- https://zhuanlan.zhihu.com/p/36120420

### 算法稳定的好处

- 一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用
- https://blog.csdn.net/wgllovemother/article/details/82801781

###  常见的稳定与不稳定算法

稳定：冒泡排序 插入排序 归并排序 基数排序

不稳定：

- 选择排序 
  - 序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了

-  快速排序  
  - 不稳定发生在中枢元素和a[j] 交换的时刻

- 希尔排序 
  - 一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的

- 堆排序
  - 当父子节点之间交换位置，可能就会影响稳定性

## 希尔排序

### 思路

- 也称递减增量排序算法
  - （设定一个增量，将元素划为符合增量的区域，之后逐次递减至1 ）
  - 增量的取值
    - 排序创始者建议 n/2 直到取到1 为止
    - 目前最好的取法可从如下链接自行查看：
    - [https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F](https://zh.wikipedia.org/wiki/希尔排序)
- 希尔排序是基于插入排序的改进版，是非稳定排序算法
- 插入排序低效的原因：每次只能将数据移动一位
- 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了

![算法03](G:\笔记\数据结构和算法图片\算法03.png)

### 代码实现 

```javascript
function shellSort(arr) {
  //解构取出数组长度
  const {length} = arr
  //设定初始增量
  let gap = Math.floor(length / 2)
  //增量必须大于才可以进行下一步
  while(gap >= 1) {
    //从增量开始向后遍历元素
    for (let i=gap; i<length; i++) {
      //保存当前遍历元素的索引到j
      let j = i
      //保存当前元素索引对应的值到temp
      const temp = arr[i]
      //对处于对应增量的值进行比较排序
      // 注意这里的while循环条件必须写temp不能写arr[i] 因为arr[i]值会变化
      while (arr[j-gap] > temp && j > gap-1) {
        arr[j] = arr[j-gap]
        j -= gap
      }
      arr[j] = temp
    }
    //减少增量，重新开始新一轮遍历
    gap = Math.floor(gap / 2)
  }
  return arr
}
```

### 希尔排序的效率

- 希尔排序的效率是和增量息息相关的
- 一个好的增量能够显著提升希尔排序效率，如上文链接中提到的最好取法，甚至在小数组中，排序速度比快速排序和堆排序还快（只限小数组，大数组还是快速排序快）
- 而通常来说 类似 n/ 2这样的大多数取法，速度也都是比O(n^2^)类算法要快的

## 快速排序

### 思路

- 快速排序最重要的思想是分而治之
- 排序步骤：
- 首先从数列中取出一个基准值
- 然后将大于基准的数据放到基准后面 ，小于基准的数据放在前面，等于可以随意放置
- 之后从两边继续取出基准，递归的将数据放到基准两边
- 当递归到最底部，数列的大小是0或1时，此时数列已经有序

### 代码实现

- 基准值的选择，在快速排序中，好的基准值，对效率至关重要，这里我们选择取头尾中间三个数，之后将其排序，取中位数作为基准值

```javascript
function median(left,right,arr) {
  let mid = Math.floor((left+right) / 2)
  if (arr[left] > arr[mid]) {
    [arr[left],arr[mid]] = [arr[mid],arr[left]]
  }
  if (arr[left] > arr[right]) {
    [arr[left],arr[right]] = [arr[right],arr[left]]
  }
  if (arr[mid] > arr[right]) {
    [arr[mid],arr[right]] = [arr[right],arr[mid]]
  }
  [arr[mid],arr[right-1]] = [arr[right-1],arr[mid]]
  return arr[right-1]
}

//快速排序的实现

function quickSort(arr) {
  quick(0,arr.length-1,arr)
  return arr
}

function quick(left,right,arr) {
  //1.结束条件
  if (left >= right) return
  //2.获取基准值
  const basic = median(left,right,arr)
  //3.定义变量，用于记录当前找到的位置
  let i = left
  let j = right - 1
  //4.开始进行交换
  //这里只能设为i<j,为了避免i=j时进入循环 ，++i出现问题
  // 比如 5 1两个元素 ij 原本都在5处
  // 加了1之后就会，底下的第五步操作，基准位置就会不变，那么最终的排序还是5,1
  while (i < j) {
    while (arr[++i] < basic) {}
    while (arr[--j] > basic) {}
    if (i < j) {
      [arr[i],arr[j]] = [arr[j],arr[i]]
    } else {
      break
    }
  }
  //5.将基准放在正确的i位置上
  [arr[i],arr[right-1]] = [arr[right-1],arr[i]]
  //6.分而治之
  quick(left, i-1,arr)
  quick(i+1, right,arr)
}
```



### 快速排序的效率

- 平均效率为O(nlog~n~) ，最低的效率为O(n^2^)最低效率并不常见，如上述通过合理的选择基准值，基本不会出现最低效率情况

