# 数据结构

## 数据结构的理解：

- 简单的说，它就是在计算机中存储，组织数据的方式

## 什么是线性结构

线性结构是一个有序数据元素的集合

常用的线性结构有：线性表，栈，队列，双队列，串。

## 数组(Array)

- 数组的创立需要开辟一块连续的内存空间
- `javascript`中的数组都是封装好的`而在其他语言中`,比如`java`它的数组更偏向底层 ，它的数组元素不能存放不同的类型，并且数组的容量是在创建时就固定的，一旦数组增加元素，那么就需要新开辟一个更大的内存空间，将原有数组复制过去，成为新的数组
- 数组的缺点，如果不是在最后，而是在前面插入元素，效率要比链表低，每插入一个都要移动其后的所有元素，其次如果想要根据元素来查找对应位置，需要先排序，之后进行二分查找
  优点:方便查找
- 时间复杂度：删除或添加 O(n)  查找O(1)

### 用数组保存裴波那契数列(fibonacci)前20个数

- 裴波那契数列：第一个数是1，第二个数是1，每连续的三个数字，第三个数是前两个数字之和

```javascript
const fibonacci = []
fibonacci[0] = 1
fibonacci[1] = 1
for(let i=2; i<20; i++) {
    fibonacci[i] = fibonacci[i-1] + fibonacci[i-2]
}
alert(fibonacci)
```

### 数组添加元素

```javascript
const numbers = [214,235,61,6172,84]
//数组最后添加 
//第一种
numbers[number.length] = 45
//第二种
numbers.push(51)
//数组最前面添加 
//第一种
numbers.unshift(25)
//第二种
for(let i=numbers.length; i>0; i--) {
    number[i] = number[i-1]
}
number[0] = 95

```

### 数组删除元素

```javascript
//删除最后
//第一种
numbers.pop()
//删除最前
//第一种
number.shift()
//第二种
for(let i=0; i<num.length; i++) {
    a[i] = a[i+1]
}
number.pop()
```

### 数组splice 方法可以完成指定位置，增加修改删除

### 数组的其他相关方法还有很多，暂不一一叙述，可查阅相关文档



## 栈(Stack)![数据结构01](G:\笔记\数据结构和算法图片\数据结构01.png)

- 后进先出

### 函数调用栈

- 执行a函数，执行b函数，执行c函数 
- 结束执行c函数 结束执行b函数 结束执行a函数 
- 比较典型的函数调用栈
  - 递归 
  - `js`文件的执行,它一运行就会首先执行`window`，直到浏览器关闭时才`最后终止`

### 基于数组实现栈

```javascript
function Stack() {
  //这里的方法我们全部写在Stack类的原型上 因为我们要求这里的方法是每个Stack实例都通用的 ，如果单纯创建构造在函数中，每个实例之间的方法都不会产生联系，而且每次创建实例，都会重新创建方法，消耗了不必要的资源，所以我们需要将方法定义在原型里
    
    this.items = []
    //将元素压入栈
    Stack.prototype.push = function (element) {
        return this.items.push(element) //返回值是栈中元素
    }
    //将元素取出栈
    Stack.prototype.pop = function () {
        this.items.pop() //返回值是取出的元素
    }
    //查看栈顶元素
    Stack.prototype.peek = function () {
        return this.items[length-1]
    }
    //判断栈是否为空
    Stack.prototype.isEmpty = function () {
        return this.items.length === 0
    }
    //查看栈中元素数量
    Stack.prototype.size = function () {
        return this.items.length
    }
    //栈的toString方法 测试时可以使用alert方法 alert自动调用toString
    Stack.prototype.toString = function () {
        return this.items.join(' ')
    }
    
}

```

### 基于创建的栈实现 十进制数转为二进制数

```javascript
function decToBin(decimal) {
    const stack = new Stack()
    while(decimal > 0) {
        stack.push(decimal%2)
        decimal = Math.floor(decimal/2)
    }
    let binary = ''
    while(!stack.isEmpty()) {
        binary += stack.pop()
    }
    return Number(binary)
}
```



## 队列(Queue)

- 先进先出![数据结构02](G:\笔记\数据结构和算法图片\数据结构02.png)

### 线程队列

开发中为了让任务并行处理，通常会开启多个线程，但大量的线程同时启用会占用过多资源，有时我们就会使用线程队列，它会依照次序依次启动线程，并处理相应的任务

### 基于数组实现队列

```javascript
function Queue() {
  this.items = []
  //添加元素
  Queue.prototype.enQueue = function (element) {
    return this.items.push(element)
  }
  //删除队列首端元素
  Queue.prototype.deQueue = function () {
    return this.items.shift()
  }
  //查看队列首端元素
  Queue.prototype.front = function () {
    return this.items[0]
  }
  //判断队列是否为空
  Queue.prototype.isEmpty = function () {
    return this.items.length === 0
  }
  //查看队列元素个数
  Queue.prototype.size = function () {
    return this.items.length
  }
  //队列的toString方法 测试时可以使用alert方法 alert自动调用toString
  Queue.prototype.toString = function () {
    return this.items.join(' ')
  }
}
```

### 通过队列实现击鼓传花游戏

规则：固定队伍人数 ，通过给出一个固定数字，之后开始在队伍中循环，每次当固定数字和队伍中数字相符时，淘汰这个人，之后继续循环，直到剩一个人为止，求这个人在原先队伍中的位置

```javascript
function game(arr,num) {
    //创建一个队列实例
  const queue = new Queue()
  //将传入的数组，放入实例中
  arr.forEach(item => {
    queue.enQueue(item)
  })
    //队列中元素数量大于1时循环执行
  while (queue.size() > 1) {
      //因为数组第一个数下标是0
      //所以这里要将num-1之前的数，全部放到队列尾部
    for (let i=0; i<num-1; i++) {
      queue.enQueue(queue.deQueue())
    }
      //删除队列头部的数
    queue.deQueue()
  }
  console.log(queue.size())
  console.log(queue.front())
    //返回队列中剩下的最后一个数，在原数组中的位置
  return arr.indexOf(queue.front())
}
```

### 优先级队列(Priority Queue)

#### 线程中的优先级队列

- 在线程队列的基础上，如果有的线程优先级更高，会将其加到线程队列靠前的位置，优先执行

#### 优先级队列的实现

思路：

- 不能单纯传递数据，要携带他们的优先级 (携带多个数据只能使用对象，而为了对象不会重复使用，产生覆盖，所以我们需要封装一个构造函数，构造函数的每个实例对象除了它们的原型外，都不会产生联系)
- 加入队列时进行优先级的比较，优先级高的靠前(此处我们默认数字越小，优先级越高)

```javascript
function PriorityQueue() {
    //封装的构造函数，存储数据和优先级
  function QueueElement(element, priority) {
    this.element = element
    this.priority = priority
  }

  this.items = []
    //优先队列添加元素方法
  PriorityQueue.prototype.enQueue = function (element, priority) {
      //创建一个队列元素实例 将元素和优先级传入
    const queueElement = new QueueElement(element, priority)
   //当队列为空， 实例直接传入
    if (this.items.length === 0) {
      this.items.push(queueElement)
    } else {
        //如果队列不为空
      let select = false
      //从队列第一个元素开始依次判断priority是否大于新的实例，如果大，证明新1的优先级高，将实例插入该元素前面
      this.items.find((item,index) => {
        if (queueElement.priority < item.priority) {
          this.items.splice(index,0,queueElement)
          select = true
          return item
        }
      })
       //如果不大，将实例放在队列最后 
      if (!select) {
        this.items.push(queueElement)
      }
    }
  }
  //删除队列首端元素
  PriorityQueue.prototype.deQueue = function () {
    return this.items.shift()
  }
  //查看队列首端元素
  PriorityQueue.prototype.front = function () {
    return this.items[0]
  }
  //判断队列是否为空
  PriorityQueue.prototype.isEmpty = function () {
    return this.items.length === 0
  }
  //查看队列元素个数
  PriorityQueue.prototype.size = function () {
    return this.items.length
  }
  //队列的toString方法
  PriorityQueue.prototype.toString = function () {
    return this.items.join(' ')
  }
}
```

## 链表(linked list)

- 元素在内存中不一定存储在连续的空间中
- 每个元素由两部分组成，元素自身以及指向下一个元素的指针
- 缺点：查找较为麻烦，需要读取所有地址，才能找到对应得元素
- 优点：插入方便，只需要改前后两个指针，初始的内存空间也不需要固定，根据需要自行扩展
- 时间复杂度：删除或添加 O(1)  查找O(n)

![数据结构03](G:\笔记\数据结构和算法图片\数据结构03.png)

### 链表的实现

```javascript
function LinkedList() {
  function Node(data) {
    this.data = data
    this.next = null
  }
  this.head = null
  this.length = 0
  //链表最后添加元素
  LinkedList.prototype.append = function (data) {
    const newNode = new Node(data)
    //如果链表中没有元素，将指针指向新元素
    if (this.length === 0) {
      this.head = newNode
    } else {
      //如果链表中已有元素，将头指针的指向，赋给current
      let current = this.head
      //循环改变current 的指向，直到其下一次的指向为空时停止
      while (current.next) {
        current = current.next
      }
      //将新元素保存在链表最后一个元素的next中
      current.next = newNode
    }
    this.length += 1
    return true
  }
  //链表元素转字符串
  LinkedList.prototype.toString = function () {
    //将头指针的指向，赋给current
    let current = this.head
    //创建变量用于保存转换后的字符串
    let listString = ''
    //循环改变循环改变current 的指向，直到它的指向为空时停止
    // 并且再每一次循环中将对应的data取出，拼接到listString
    while (current) {
      listString += current.data+' '
      current = current.next
    }
    //返回字符串
    return listString
  }
  //链表任意位置插入元素
  LinkedList.prototype.inserted = function (position,data) {
    //越界判断
    if (position >=0 && position<=this.length) {
      const newNode = new Node(data)
      //插到第一个位置
      if (position === 0) {
        newNode.next = this.head
        this.head = newNode
      } else {
        //插到其他位置
        let index = 0
        let prev = null
        let current = this.head
        //循环index直到 index不小于position时停止 这时
        // prev指向要插入元素的前一个元素，current指向要插入元素的后一个元素
        // index++ 是执行完表达式以后执行自增 这里不能写++index ++index 是执行完自增执行表达式
        while (index++ < position) {
          prev = current
          current = current.next
          //index++ 就相当于 在这里执行
        }
        prev.next = newNode
        newNode.next = current
      }
      this.length += 1
      return true
    }
    return false
  }
  //获取指定位置的元素
  LinkedList.prototype.get = function (position) {
    if (position < 0 || position>=this.length) return null
    let current = this.head
    let index = 0
    while (index++ < position) {
      current = current.next
    }
    return current.data
  }
  //获取指定元素的位置
  LinkedList.prototype.indexOf = function (data) {
    let current = this.head
    let index = 0
    while (current) {
      if (current.data === data) {
        return index
      }
      current = current.next
      index += 1
    }
    return -1
  }
  //更新指定元素
  LinkedList.prototype.update = function (position,data) {
    if (position<0 || position>=this.length) return false
    let current = this.head
    let index = 0
    while (index++ < position) {
      current = current.next
    }
    current.data = data
    return true
  }
  //删除指定位置的元素
  LinkedList.prototype.removeAt = function (position) {
    if (position<0 || position>=this.length) return null
    let current = this.head
    if (position === 0) {
      this.head = this.head.next
    } else {
      let prev = null
      let index = 0
      while (index++ < position) {
        prev = current
        current = current.next
      }
      prev.next = current.next
    }
    this.length -= 1
    return current.data
  }
  //删除元素
  LinkedList.prototype.remove = function (data) {
    this.removeAt(this.indexOf(data))
  }
  //判断是否为空
  LinkedList.prototype.isEmpty = function () {
    return this.length === 0
  }
  //返回链表长度
  LinkedList.prototype.size = function () {
    return this.length
  }
}
```

### 双向链表

![数据结构04](G:\笔记\数据结构和算法图片\数据结构04.png)

- 单向链表只能提供单向的查询，如果已经读取到了下一个节点，是无法返回前一个节点的，而双向链表很好的解决了这个问题，虽然它相对的多了一些消耗，但这些消耗对比他的性能提升来说，是微不足道的

==双向·链表的实现==

```javascript
function DoubleLinkedList() {
    //创建节点构造函数
  function Node(data) {
    this.prev = null
    this.next = null
    this.data = data
  }
//设置默认头尾 指向 及 链表长度
  this.head = null
  this.tail = null
  this.length = 0
   //append 添加元素节点到链表最后
  DoubleLinkedList.prototype.append = function (data) {
    const node = new Node(data)
    //链表无元素时
    if (this.length === 0) {
      this.tail = node
      this.head = node
    } else {
       //链表有元素时
      node.prev = this.tail
      this.tail.next = node
      this.tail = node
    }
      //长度更新
    this.length += 1
  }
    //链表的toString 方法 从前向后读 
  DoubleLinkedList.prototype.toString = function () {
    let current = this.head
    let duString = ''
    while (current) {
      duString += current.data + ' '
      current = current.next
    }
    return duString
  }
    //链表的backward方法 与toString 实现原理相同
  DoubleLinkedList.prototype.backward = function () {
    return this.toString()
  }
    //链表的forward 从后向前读取
  DoubleLinkedList.prototype.forward = function () {
    let current = this.tail
    let duString = ''
    while (current) {
      duString += current.data + ' '
      current = current.prev
    }
    return duString
  }
    //inserted 链表的插入方法 在任意位置增加元素节点
  DoubleLinkedList.prototype.inserted = function (position, data) {
     //越界判断
    if (position < 0 || position > this.length) return false
    const node = new Node(data)
    //本身没有节点
    if (this.length === 0) {
      this.tail = node
      this.head = node
    } else {
        //添加节点在开头
      if (position === 0) {
        this.head.prev = node
        node.next = this.head
        this.head = node
          //添加节点在最后
      } else if (position === this.length) {
        this.tail.next = node
        node.prev = this.tail
        this.tail = node
      } else {
          //添加节点在中间
        let current = this.head
        let index = 0
        while (index++ < position) {
          current = current.next
        }
        node.prev = current.prev
        node.next = current
        current.prev.next = node
        current.prev = node
      }
    }
      //长度更新
    this.length += 1
    return true
  }
    //get 得到指定位置的节点
  DoubleLinkedList.prototype.get = function (position) {
      //为了提高查找效率 分为两种找法，position大于等于一半从尾部节点开始找，position小于一半从头部开始找
    if (position < 0 || position >= this.length) return null
    if (position >= Math.ceil(this.length/2)) {
      let current = this.tail
      let index = this.length-1
      while (index-- > position) {
        current = current.prev
      }
      return current.data
    } else {
      let current = this.head
      let index = 0
      while (index++ <  position) {
        current = current.next
      }
      return current.data
    }
  }
    //indexOf 返回指定数据的位置
  DoubleLinkedList.prototype.indexOf = function (data) {
    let current = this.head
    let index = 0
    while (current) {
      if (current.data === data) {
        return index
      }
      current = current.next
      index += 1
    }
    return -1
  }
    //update 更新指定位置的数据 ，思路与get基本相同
  DoubleLinkedList.prototype.update = function (position,data) {
    if (position < 0 || position >= this.length) return false
    if (position >= Math.ceil(this.length/2)) {
      let current = this.tail
      let index = this.length-1
      while (index-- > position) {
        current = current.prev
      }
      current.data = data
      return true
    } else {
      let current = this.head
      let index = 0
      while (index++ < position) {
        current = current.next
      }
      current.data = data
      return true
    }
  }
    //removeAt  删除指定位置的节点
  DoubleLinkedList.prototype.removeAt = function (position) {
    //原先写了this.length === 0的判定， 后来发现不用，因为它包括在了position === 0 中
      // if (position < 0 || position >= this.length || this.length === 0) return null
      //越界判断
    if (position < 0 || position >= this.length) return null
    let current = this.head
    //本身有一个元素
    if (this.length === 1) {
      this.head = null
      this.tail = null
    } else {
        //从开头删，包括无元素（this.length===0）
      if (position === 0) {
        current.next.prev = null
        this.head = current.next
          //从结尾删
      } else if (position === this.length-1) {
        current = this.tail
        current.prev.next = null
        this.tail = this.tail.prev
      } else {
          //从中间任意位置删除
        current = this.head
        let index = 0
        while (index++ < position) {
          current = current.next
        }
        current.next.prev = current.prev
        current.prev.next = current.next
      }
    }
      //长度更新
    this.length -= 1
    return current.data
  }
    //删除指定数据的元素 同时使用 indexOf 和 removeAt 即可
  DoubleLinkedList.prototype.remove = function (data) {
    return this.removeAt(this.indexOf(data))
  }
    //非空判断
  DoubleLinkedList.prototype.isEmpty = function () {
    return this.length === 0
  }
    //数量判断
  DoubleLinkedList.prototype.size = function () {
    return this.length
  }
    //查看链表头节点
  DoubleLinkedList.prototype.getFirst = function () {
    return this.head.data
  }
    //查看链表尾节点
  DoubleLinkedList.prototype.getEnd = function () {
    return this.tail.data
  }
}
```

## 集合

- 在计算机科学中，集合是一种可变数量的数据项的组合
- 集合的种类包括列表，集，多重集，图，树 
- 列表
  - 数据项的顺序是确定的，可以存在多个相同的数据项
  - 列表的具体形式包括，数组，链表等
  - 栈，队列时特殊的列表
  - `es5`中Array是封装好的数组
- 集
  - 通常是由一组无序的不能重复的元素构成
  - 哈希表（也叫散列表） 就是比较常见的集
  - 在`es6`中新增的`set`就是一个典型的集
  - 补充：`es6中`的`  WeakSet`只存放对象的弱引用，当该对象的强引用被删除时，`WeakSet`中的弱引用也会被清除，`set`则不会
- 多重集
  - 行为类似集，但可以存在相同数据项
  - 多重集可以通过排序转换成列表
- 树
  - 根节点与一定数量的数据项以亲子关系联系起来，而其子数据项也与另外的数据项以同样的方式联系
  - 用于排序操作的树称为堆
  - 通常用树保存含亲子关系的数据，例如菜单，目录及其中的文件
- 图
  - 每个数据项都可以与一个或多个其他数据项联系起来，其中每个节点都是平等的，类似于无根节点，无亲子关系的树
  - 常用于对实际问题建模，并解决这些问题

## 集

### 集的实现

```javascript
function Set() {
    //由于集具有数据项不重复，且无序的特点，这里使用对象存储较为合适
  this.items = {}
    //向集中增加新数据项
  Set.prototype.add = function (value) {
    if (this.has(value)) return false
    this.items[value]  = value
    return true
  }
    //判断集中是否有指定数据项
  Set.prototype.has = function (value) {
    return this.items.hasOwnProperty(value)
  }
    //删除集中指定的数据项
  Set.prototype.delete = function (value) {
    if (!this.has(value)) return false
    delete this.items[value]
    return true
  }
    //清空集中所有数据项
  Set.prototype.clear = function () {
    this.items = {}
  }
    //查询集中数据项个数
  Set.prototype.size = function () {
    return Object.keys(this.items).length
  }
    //查看集中的所有数据，数组形式查看
  Set.prototype.values = function () {
    return Object.keys(this.items)
  }
    //集的并集方法
  Set.prototype.union = function (otherSet) {
    const values =  this.values()
    let unionSet = new Set()
    for (item of values) {
      unionSet.add(item)
    }
    for (item of otherSet.values()) {
      unionSet.add(item)
    }
    return unionSet
  }
    //集的交集方法
  Set.prototype.intersection = function (otherSet) {
    const values = this.values()
    let intersectionSet = new Set()
    for (item of values) {
      if (otherSet.has(item)) {
        intersectionSet.add(item)
      }
    }
    return intersectionSet
  }
    //集的差集方法
  Set.prototype.difference = function (otherSet) {
    const values = this.values()
    let differenceSet = new Set()
    for (item of values) {
      if (!otherSet.has(item)) {
        differenceSet.add(item)
      }
    }
    return differenceSet
  }
    //集的子集方法
  Set.prototype.subset = function (otherSet) {
    const values = this.values()
    let subset = new Set()
    for (item of values) {
      if (!otherSet.has(item)) {
        return false
      }
    }
    return true
  }
}
```

### 字典

- 也叫映射(Map)，一个抽象的数据结构，它包含着类似于，键(key)->值(value)的对，解决字典问题的常用方法是利用散列表。
- `es6`中，使用`Map`实现字典
- 补充：`es6中`的`  Weakmap`只存放对象的弱引用，当该对象的强引用被删除时，`WeakMap`中的弱引用也会被清除，`Map`则不会

通过对象实现字典的具体流程

```javascript
function Map() {
    this.items = {}
    //增加键值对 set 
    Map.prototype.set = function(key,value) {
        if (this.has(key)) return false
        this.items[key] = value
        return true
    }
    //判断是否存在指定key has
    Map.prototype.has = function(key) {
        return this.items.hasOwnProperty(key)
    }
    //查询指定key的value get
    Map.prototype.get = function(key) {
        return this.has(key) ? this.items[key] : undefined
    }
    //删除指定key的value delete
    Map.prototype.delete = function(key) {
        if (this.has(key)) return false
        delete this.items[key]
        return true
    }
    //删除全部的键值对 clear
    Map.prototype.clear = function(key) {
        this.items = {}
    } 
    //查询键值对的数量 size
    Map.prototype.size = function() {
        return Object.keys(this.items).length
    }
    //查询全部的key  keys
    Map.prototype.keys = function() {
        return Object.keys(this.items)
    }
    //查询全部的value values
    Map.prototype.values = function() {
        return Object.values(this.items)
    }
}
```

### 散列表(哈希表)

#### 散列表的理解

- 是根据键(key)而直接访问存储内存的数据结构
- 它基于数组，但是完善了数组插入删除效率低的缺点 插入删除都接近`O(1)` 速度比树还要快
- 缺点
- 1.数据无序
- 2.不允许重复

#### 散列表的实现

- 1.因为他是根据key值访问，所以我们就要设计一个实现key的方法
- 比如：一个散列表中保存了许多单词，每个单词都有释义，例句等等信息，如果想要查找某个单词，我们显然不能通过数字来找，这时就可以设置一个编码格式 (ASCII UTF-8 等等)，在查询时，输入单词名（key），通过计算单词的编码值，得到他的位置，从而实现快速查找，插入也是如此，通过赋予新单词一个新的编码值，来快速保存
- 2.如何转化：
- 这里为了方便计算，我们自己设置一种编码方式
- a-z 代表十进制 1-26 空格 代表十进制的 0
- 首先不能通过单纯的加来计算编码，因为这样会出现重复码值得情况，如`abc` 和 `f`的码值就相同
- 其次，可以考虑使用幂的连乘 如 `abc` : 1 * 27^2^ + 2 * 27^1^ + 3 * 27^0^ 这样基本不会造成重复，但占用内存过大，有很多浪费的空间 所以同样排除
  
  - 补充：上述连乘的思路来源,每个字母在每个位置包括空格的0一共有27个,所以可以将它看成27位进1，这样就能枚举所有的可能，因为数组下标是10进制，所以我们再将27进制转为10进制就能得到上述方法。缺点也如上述所说，实际单词远远没有枚举所展示的那么多，有很多空位所以需要考虑其他方法
- 最终方法 ：哈希化

#### 哈希化 哈希函数 哈希表的关系

- 哈希化：将大数字转化成数组下标的过程称为哈希化
- 哈希函数： 我们通过会将实现哈希化的代码放在一个函数中，这个函数就称为哈希函数
- 哈希表： 将数据存放哈希函数的到的地址中，形成一一对应关系的表，这个表就是哈希表

#### 哈希表的常见构造方法：

- 直接定址法  
  - 例如有 1到 100岁的人口统计表，年龄为关键字,哈希函数就直接取关键字自身
- 数字分析法  
  - 比如有生日数据为 98.10.01   97.11.21    97.03.05
  - 通过分析发现 前三位易重复，后三位随机性更大，所以取后三位
- 平方取中法 
  - 取关键字平方后的中间几位位哈希地址
- 折叠法 
  - 将关键字分为位数相同的几部分(最后一部分位数可以不同)，然后取这几部分的叠加和(舍去进位形成哈希地址)
-  除留余数法  
  - 取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址
- 随机数法
  - 选择一个随机函数，取关键字的随机函数值为它的哈希地址

#### 解决哈希表冲突的方法

- 拉链法(链地址法)：拉出一个动态链代替静态顺序结构，可以避免冲突，但缺点是设计麻烦，增加了编程复杂度
  - （这里不光拉出链表可以，拉出数组也可以，因为在第一次根据哈希化的地址找到对应的数组或链表后，在查找具体的数据，都是通过线性查找，一个个再具体找到的，不能一次性得到，这样查找的效率基本上是一致的
  - 注：子数组只能线性查找的原因是，我们保存的只有哈希化的静态数组地址，没有子数组的地址，所以子数组也只能线性）
  - 补充： 拉出数组可以还有一个前提，那就是冲突的数据是插在拉出的数组最后的，如果是插在前面，则还是使用链表，因为数组插入前面的时间复杂度为O(n)
  
   
  
  **2.**设记录关键字集合 key={32,13,49,55,22,39,20}，选取哈希函数为 H(x)=key mod 7；解决冲突的方法为“链地址法”。
  
  **（1**）画出所构造的哈希表；
  
  **（2**）求该哈希表查找成功和查找不成功情况下的平均查找长度
  
  **（1****）
  
  ![img](G:\笔记\数据结构和算法图片\数据结构51.png)
  
  成功：每个数据几次插到链尾的和/数据数量
  
  **成功：ASLsucc= (1\*4+2\*2+3)/7=11/7;** 
  
  不成功：每个链前面有几个数据的和 除以数组长
  
  **不成功：ASLnsucc= (1+1+2+3)/7=7/7=1**

![数据结构06](G:\笔记\数据结构和算法图片\数据结构06.png)



- 开放地址法 ：也细分为多种方法

  - 线性探测法； 冲突时 将原本地址，向后移一位，如果再冲突，再向后移，直到不冲突位置

  例：

  **1.** **设记录关键字集合 key={33,20,53,55,23,38,40,65}**，选取哈希函数为 H(x)=key mod 11；解决冲突的方法为“线性探测法”。

  **（1**）请按上述条件将 key **中各值依次填入下表中：**

  | **0**  | **1**  | **2**  | **3**  | **4** | **5**  | **6** | **7**  | **8** | **9**  | **10** |
  | ------ | ------ | ------ | ------ | ----- | ------ | ----- | ------ | ----- | ------ | ------ |
  | **33** | **55** | **23** | **65** |       | **38** |       | **40** |       | **20** | **53** |
  
   ==补充== 拿65举例，如果查找到结尾还是没位置，会从头重新开始找，直到找到位置
  
  **（2**）求该哈希表查找成功和查找不成功情况下的平均查找长度。
  
  成功平均查找长度： 每次查找次数和/ 数据长度
  
  **成功：(1+2+2+5+1+1+1+2)/8=15/8;** 
  
  不成功平均查找长度： 
  
  **不成功：(5+4+3+2+1+2+1+2+1+7+6)/11=34/11**
  
  
  
  - 二次探测法： 冲突时 从 +1 ，-1 ， +4 ，-4 ，+9 ，-9.....开始依次向两边探测，直到有空位为止
  
  
  
  - 多哈希法(再哈希法)：设置二种甚至多种哈希函数，来避免冲突
    - 比如设置两种哈希函数 第二种需要具备以下特点:
    - 新的哈希函数需要和前面的哈希函数不同
    - 哈希函数不能输出为0 
    - 下面的双散列法就是一个完整的例子
  - 双散列法：  根据双散列函数
  -  h(k,i)=(k mod h + i(1+k mod z)) mod h 进行计算
  - k是插入的数据默认映射地址  i为探测次数 第一次是0之后每次加1 mod为取模  h为数组长度(为质数)  z为h下的最大质数
  - 比如插入59 得到位置4 但如果位置4已被占用
  - h(59,0)=(59 mod 11 + 0*(1+59 mod 9)) mod 11=4
  - 则计算下一次 得到10 如果10为空则插入，如果不为空，按照此方式继续计算
  - h(59,1)=(59 mod 11 + 1*(1+59 mod 9)) mod 11=10

![数据结构05](G:\笔记\数据结构和算法图片\数据结构05.png)

==注意== 开放地址法有一个需要注意的问题，比如，我们使用线性探测，来解决冲突，假设相同哈希的数据出现在数组 1,2,3 的位置， 这时我们删除 位置1 数据的时候，注意不能将其设为 null 因为如果这样我们查询 位置2 位置3 的数据 就会先根据哈希表的key查找 1 发现1 为空 ，就会认为数据不存在，从而返回false ，所以一般情况下，删除掉的数据，我们将其值，设为 -1 来避免上述情况

#### 哈希化的效率

- 如果无冲突，效率很高
- 如果有冲突，存取时间就依赖后来的探测长度
- 平均探测长度以及平均存取时间，取决于`装填因子(Load Factor)` 
- 装填因子 = 总数据项 / 哈希表的长度
- 开放地址法的装填因子最大是 1 
- 链地址法 可以大于1 因为拉链可以无限延伸下去
- 通过分析可以得出 同等长的数组，随着数据项的增长哈希化效率更高的是链地址法

#### 哈希函数的设计思路

- 尽可能减少乘除法，提高计算速度
- 尽可能让数据分布的更均匀

- 通过`霍纳法则`优化前面使用过的多项式求值连乘方法

- 原方法: 3*27^3^  + 1 * 27^2^ + 2 * 27^1^ + 3 * 27^0^       时间复杂度O(n^2^)

   // n+(n-1)+...1 = n(n-1) /2       即 n(n-1) /2 次乘法             n次加法 

- 现方法: 27(27(3*27+1)+2)+3        时间复杂度O(n)  // n次乘法 n次加法

#### 哈希表的长度

- 开放地址法数组长度应该尽量取质数 
- 如果不是质数 比如15（下标为0~14） ，那么如果步长为5   有一个特定关键字默认映射在0  它的探测序列就会在 0， 5，10 之间一直往复循环，从而形成死循环
- 而如果取 质数 13(下标为0~12) 步长为 5  关键字映射在0  那么探测序列就是 0，5 ， 10 ，2  ，7 ，12 ，4 ，9 ，1 ，6 ，11  ，3 ，8完全不会出现冲突问题
- 注： 这里的步长就是指每一次探测的长度 是根据哈希函数的值来确定的
- 链地址法不会出现这种问题，长度没有硬性要求

#### 构建哈希表

- 综上所述，我们决定使用链地址法构造JavaScript哈希表
- 在java中 哈希表采用了链地址法解决冲突，且计算下标采用了位与运算方式
- 在JavaScript中，位与运算数字过大，有时会产生一些问题，于是采用除留余数法计算下标，且为了之后代码的可迁移性，数组长度也设为质数

```javascript
//哈希函数的设计
//设计思路 ，先将字母转为大数字(为了提升计算性能使用霍纳算法)，然后通过除留余数法将其转为数组下标
function hashFunc(str,size) {
  let hashCode = ''
  for (let i=0; i<str.length; i++) {
      //霍纳算法
    hashCode = 37 * hashCode + str.charCodeAt(i)
  }
  return hashCode % size

}
```

```javascript
function HashTable() {
    //存储哈希表的数组
  this.storage = []
    //存入数据的数量
  this.count = 0
    //哈希表的长度（即this.storage的长度）
  this.limit = 7
    
    //在原型上新建哈希函数
  HashTable.prototype.hashFunc = function (key,size) {
    let hashCode = ''
    for (let i=0; i<key.length; i++) {
      hashCode = 37 * hashCode + key.charCodeAt(i)
    }
    return hashCode % size
  }
    
    
    //添加以及修改数据方法
  HashTable.prototype.put = function (key,value) {
      //调用哈希函数求出 存储位置 index
    const index = this.hashFunc(key,this.limit)
    //根据位置，在storage中得到对应的bucket
    let bucket = this.storage[index]
    //如果bucket未定义,则给其赋值一个空数组，并将对应的this.storage[index]指向该数组
    if (bucket === undefined) {
      bucket = []
      this.storage[index] = bucket
    }
      //判断是bucket(桶)中数据是否已存在
    for (let i=0; i<bucket.length; i++) {
        //遍历每一个桶中的tuple(元组)
      const tuple = bucket[i]
      //对比tuple的key 如过已存在
      if (tuple[0] === key) {
          //更新value
        tuple[1] = value
          //跳出put方法
        return
      }
    }
      //如果之前的更新操作未执行，则证明数据原先不存在，那么将新数据添加到桶中 
    bucket.push([key,value])
      //更新数据数量
    this.count += 1
    //如果数据数量大于数组长度的0.75倍  对数组长度进行扩容
    if (this.count > this.limit * 0.75) {
        //扩容长度取质数
      const newLimit = this.getPrimeNum(this.limit * 2)
      //调用扩容函数
      this.resize(newLimit)
    }
  }
    
   //获得指定key的数据
  HashTable.prototype.get = function (key) {
    const index = this.hashFunc(key,this.limit)
    let bucket = this.storage[index]
    //如果要查找key所在的桶未定义，返回null
    if (bucket === underfined) return null
      //遍历桶中的数据如果找到符合的数据，返回该数据的value
    for (let i=0; i<bucket.length; i++) {
      const tuple = bucket[i]
      if (tuple[0] === key) {
        return tuple[1]
      }
    }
      //如果遍历bucket之后仍未找到，返回null
    return null
  }

    //删除指定key的数据
  HashTable.prototype.remove = function (key) {
    const index = this.hashFunc(key,this.limit)
    let bucket = this.storage[index]
    //如果要查找key所在的桶未定义，返回null
    if (bucket === underfined) return null
    //遍历桶中的数据如果找到符合的数据，删除桶中的该数据，更新数据数量count
    for (let i=0; i<bucket.length; i++) {
      const tuple = bucket[i]
      if (tuple[0] === key) {
        bucket.splice(i,1)
        this.count -= 1
        
  //如果数组长度大于7 且数据占用的容量小于数组长度的0.25倍 ，对数组进行收缩
       if (this.limit >= 7 && this.count < this.limit * 0.25) {
           //得到新数组长度为质数
          const newLimit = this.getPrimeNum(Math.floor(this.limit/2 ))
          //调用收缩函数
          this.resize(newLimit)
        }
        
        // 返回数据得value
        return tuple[1]
      }
    }
       //如果遍历bucket之后仍未找到，返回null
    return null
  }
    
    //判断哈希表是否为空
  HashTable.prototype.isEntry = function(){
    return this.count === 0
  }
   //查询哈希表数据数量
  HashTable.prototype.size = function() {
    return this.count
  }
   //对哈希表进行扩容，或收缩
  HashTable.prototype.resize = function (newLimit) {
    const oldStorage = this.storage
    this.storage = []
    this.count = 0
    this.limit = newLimit
    for (let i=0; i<oldStorage.length; i++) {
      let bucket = oldStorage[i]
      if (bucket === undefined) {
        continue
      }
      for (let j=0;j<bucket.length;j++) {
        let tuple = bucket[j]
        this.put(tuple[0],tuple[1])
      }
    }
  }
    //质数判断函数
  HashTable.prototype.isPrimeNum = function (num) {
    const temp = Math.floor(Math.sqrt(num))
    for (let i=2; i<=temp; i++) {
      if (num % i === 0) {
        return false
      }
    }
    return true
  }
   //返回任意数最近的一个质数
  HashTable.prototype.getPrimeNum = function (num) {
    while (!this.isPrimeNum(num)) {
      num++
    }
    return num
  }
}
```

补充：判断是否是质数的算法

```javascript
//质数：除了1和它本身以外，不再有其他因数的自然数
//因数: 整数a除以整数b，商是整数无余数，那么b就是a的因数

//第一种方法 效率较低
function isPrimeNum(num) {
  for (let i=2; i<num; i++) {
    if (num % i === 0) {
      return false
    }
  }
  return true
}

//第二种方法  效率高
//因为将一个整数因式分解，它较小的因数小于等于该整数的平方根，较大的因数，大于等于该整数的平方根
//由此可以所以for循环的次数，达到提高效率的目的
function isPrimeNum(num) {
  const temp = Math.floor(Math.sqrt(num))
  for (let i=2; i<=temp; i++) {
    if (num % i === 0) {
      return false
    }
  }
  return true
}
```

==哈希表的优缺点==

优点: 插入 删除 查询效率都很高`O(1)`

缺点：空间利用率不高，底层使用数组，某些单元没有被利用； 元素是无序的，无法遍历 ； 不能快速的找出哈希表中最大值或最小值这些特殊的值





## 1.9 树

### 树的相关名词

- 树（tree）是包含n（n>=0）个节点的有穷集
- 空集合也是树，称为空树。空树中没有节点。
- 节点的度：一个节点含有的子树的个数称为该节点的度
- 树的度：一棵树中，最大的节点的度称为树的度
- 叶节点或终端节点：度为0的节点称为叶节点；
- 非终端节点或非叶子节点：度不为0的节点；
- 双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
- 子节点：若A点是B点的父节点，则B是A的子节点
- 兄弟节点：具有相同父节点的节点互称为兄弟节点
- 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推
- 树的高度或深度：树中节点的最大层次；
- 堂兄弟节点：双亲在同一层的节点互为堂兄弟
- 节点的祖先：从根到该节点所经分支上的所有节点
- 子孙：以某节点为根的子树中任一节点都称为该节点的子孙
- 森林：由m（m>=0）棵互不相交的树的集合称为森林

### 树的种类：

- 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树,也称为自由树

- 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树

- 二叉树：每个节点最多含有两个子树的树称为二叉树；

  - 二叉树的性质： n0  = n2 +1 度为0的节点数量是度为2的节点数量加1
  - 二叉树的孩子节点：左孩子位2i右孩子为2i+1
  - 二叉树第i层(或深度为i)的最大节点数为： 2^i-1^     (i>=1)
  - 二叉树的遍历
    - 先(前)序遍历（PreOrderTraversal） ：根节点最先，同级先左后右
      - (根节点在开头)
    - 中序遍历(InOrderTraversal) ： 先左后根最后右
      - (根节点在中间随机位置)
    - 后序遍历(PostOrderTraversal)  ： 先左后右最后根
      - (根节点在结尾)
      - 注：知道根节点的位置有利于根据给出的遍历，还原二叉树
  - 层序遍历：从上到下，从左到右一层层遍历
  - 补充:
  - 深度优先遍历（DFS）: 先中后序遍历
    - 通过栈实现
  - 广度优先遍历（BFS）:  层序遍历
    - 通过队列实现
  
  ![数据结构08](G:\笔记\数据结构和算法图片\数据结构08.png)

例：由 3 个节点可以构造出（  5  ）种不同的二叉树。

此处涉及组合,可以通过公式 ： C(2n,n) / ( n+ 1) 计算 

排列组合详解，参考文章：https://zhuanlan.zhihu.com/p/41855459



- 满二叉树：除最后一层无任何子节点外，每一层上的所有节点都有两个子节点的二叉树。
- 完全二叉树：如果一棵具有n个节点的深度为k的二叉树，它的每一个节点都与深度为k的满二叉树中编号为1~n的节点一一对应，这棵二叉树称为完全二叉树

  - 完全二叉树中度为1的节点最多只能有1个也就是取值为（0或1）
  - 完全二叉树的层（高）等于 ==log~2~节点数量==向上取整
  - 完全二叉树最后一个非叶子节点等于： ==节点个数/2 - 1== （向下取整）

![数据结构07](G:\笔记\数据结构和算法图片\数据结构07.png)

- 霍夫曼树(哈夫曼树)：带权路径最短的二叉树称为哈夫曼树或最优二叉树
  - 哈弗曼树中只有两种类型的节点：度为0或度为N(几叉n就为几)
  - 哈夫曼编码：从根节点开始，左0右1 。在给编码还原树时，照着画即可
  -  一棵有n个叶子节点的哈夫曼树，它的节点总数为（  ==2n-1==），叶子节点就是度为0的节点，因为二叉哈夫曼树中只有度为0和度为2的节点 又因为 n0 = n2-1 即 n2 =n0+1 所以 节点总数就是 n+n+1 = 2n + 1

- ​	节点的权：若将树中节点赋给一个有着某种含义的数值，则这个数值称为该节点的权
- 节点的带权路径长度：从根节点到该节点之间的路径长度与该节点的权的乘积。
- 树的带权路径长度：树的带权路径长度规定为所有叶子节点的带权路径长度之和

由权值分别为3,8,6,2,5的叶子节点生成一棵哈夫曼树，它的带权路径长度为 (53)

![数据结构09](G:\笔记\数据结构和算法图片\数据结构09.png)

### 堆

- 堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象

- 堆排序的理解

- 参考资料  https://www.cnblogs.com/chengxiao/p/6129630.html

- 堆排序思路

- 　a.将无序序列构建成一个堆，升序选择大顶堆，降序选择小顶堆

    　　b.将堆顶元素与末尾元素交换，将最大元素(最小元素)"沉"到数组末端;

        　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

大顶堆 （升序演示）

1.初始数组

![数据结构10](G:\笔记\数据结构和算法图片\数据结构10.png)

2.通过 5 / 2  -1 = 1.5 ≈  1 得到最后一个非叶节点，通过该节点开始排序（之后每一个非叶节点，都在上一个非叶节点的基础上减一即可）

2.1 将该非叶节点与其左右子节点比较大小，将大的往上升

![数据结构11](G:\笔记\数据结构和算法图片\数据结构11.png)

2.2该非叶节点排序完毕后，找到上一个非叶节点，继续排序交换

![数据结构12](G:\笔记\数据结构和算法图片\数据结构12.png)

2.3 检查这个交换是否会影响其他节点，如果发现影响，将被影响的节点重新排序

![数据结构13](G:\笔记\数据结构和算法图片\数据结构13.png)

2.4 当最大的节点位于根节点时将其与末尾元素交换，之后再次重复上述步骤

![数据结构14](G:\笔记\数据结构和算法图片\数据结构14.png)

2.5 直到最后得出升序完毕的数组为止

![数据结构15](G:\笔记\数据结构和算法图片\数据结构15.png)

### 树的三种表示方法

这里的树统一使用图一中的（A）

- 双亲表示法 

  当需要频繁的查找某节点的父节点时，使用双亲表示法最合适

![数据结构19](G:\笔记\数据结构和算法图片\数据结构19.png)

- 孩子表示法

  当需要查找某节点的孩子节点时，使用孩子表示法

![数据结构20](G:\笔记\数据结构和算法图片\数据结构20.png)

- 前两种方法结合使用：孩子双亲表示法

![数据结构21](G:\笔记\数据结构和算法图片\数据结构21.png)

- 孩子兄弟表示法
  - 简单的说就是，左孩子，右兄弟

![数据结构22](G:\笔记\数据结构和算法图片\数据结构22.png)



### 树和森林的转换

- 任何树（森林）都可以通过二叉树的方式表示出来
- 转化步骤：
- 1.首先将森林中树各自转化为二叉树；
- 2.森林中第一棵二叉树的树根作为转化后二叉树的树根；
- 3.其他树的树根作为第一棵树树根的兄弟节点，进行连接；

某二叉树的中序遍历结果为 DEFABCG；后序遍历结果为 FEDCBAG。

（1）画出此二叉树，并给出其先序遍历的结果。

（2）画出与这棵二叉树对应的树（森林)。

答：![数据结构16](G:\笔记\数据结构和算法图片\数据结构16.png)

已知一个二叉树的先序遍历序列为：ABDGIECFH；中序遍历序列为：DIGBEAFHC。

（1）画出该二叉树。

（2）画出下图所示森林对应的二叉树。

![数据结构17](G:\笔记\数据结构和算法图片\数据结构17.png)

![数据结构18](G:\笔记\数据结构和算法图片\数据结构18.png)

### 关于树和森林的遍历

#### 树的遍历

- 先根遍历： 与对应二叉树的先序遍历相同
- 后根遍历： 与对应二叉树的中序遍历相同

#### 森林的遍历

- 以下的二叉树森林是指将森林中所有树，转为二叉树之后得到的森林

  

- 森林的先根遍历

- 二叉树森林的先序遍历： 与完整二叉树的先序遍历相同

  

- 森林的后根遍历

- 二叉树森林的中序遍历：与完整二叉树的中序遍历相同，与森林的后根遍历相同

### 二叉树的存储

#### 完全二叉树

前文已经提及过，对于完全二叉树，可以使用数组的方式，按它的深度，从左到右依次存储，这样存储的完全二叉树也就是堆，之后使用堆排序来对数组进行排序

#### 非完全二叉树

对于非完全二叉树，如果使用数组，那么需要将其转为完全二叉树，这样会造成空间浪费

![数据结构23](G:\笔记\数据结构和算法图片\数据结构23.png)

所以我们使用链表来存储这种二叉树

![数据结构24](G:\笔记\数据结构和算法图片\数据结构24.png)

### 二叉搜索树（Binary Search Tree）

定义：是指一颗空树或具有下列性质的二叉树

1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点。

![数据结构25](G:\笔记\数据结构和算法图片\数据结构25.png)

- 二叉搜索树的实现
- 时间复杂度：插入，删除，搜索 O(log~(n)~)

测试用图

![数据结构26](G:\笔记\数据结构和算法图片\数据结构26.png)

```javascript
function BinarySearchTree() {
  //创建树节点
  function Node(key) {
    this.key = key
    this.left = null
    this.right = null
  }
  //root节点
  this.root = null
  //添加树节点方法
  BinarySearchTree.prototype.insert = function (key) {
    const newNode = new  Node(key)
    //判断root是否为空 如果为空 则将其指向新节点
    if (this.root === null) {
      this.root = newNode
    } else {
      //如果不为空调用insertNode方法进行判定
      this.insertNode(this.root,newNode)

    }
  }
  //左右子节点插入方法,由insert 方法自行调用
  BinarySearchTree.prototype.insertNode = function (oldNode,newNode) {
    if (oldNode.key > newNode.key) {
      if (oldNode.left === null) {
        oldNode.left = newNode
      } else {
        this.insertNode(oldNode.left,newNode)
      }
    } else {
      if (oldNode.right === null) {
        oldNode.right = newNode
      } else {
        this.insertNode(oldNode.right,newNode)
      }
    }
  }

  //先序遍历
  BinarySearchTree.prototype.preOrderTraversal = function (callBack) {
    this.preOrderTraversalNode(this.root,callBack)
  }
  BinarySearchTree.prototype.preOrderTraversalNode = function (node,callBack) {
    if (node !== null) {
      callBack(node.key)
      this.preOrderTraversalNode(node.left,callBack)
      this.preOrderTraversalNode(node.right,callBack)
    }
  }
  //中序遍历
  BinarySearchTree.prototype.inOrderTraversal = function (callBack) {
    this.inOrderTraversalNode(this.root,callBack)
  }
  BinarySearchTree.prototype.inOrderTraversalNode = function (node,callBack) {
    if (node !== null) {
      this.inOrderTraversalNode(node.left,callBack)
      callBack(node.key)
      this.inOrderTraversalNode(node.right,callBack)
    }
  }
  //后序遍历
  BinarySearchTree.prototype.postOrderTraversal = function (callBack) {
    this.postOrderTraversalNode(this.root,callBack)
  }
  BinarySearchTree.prototype.postOrderTraversalNode = function (node,callBack) {
    if (node !== null) {
      this.postOrderTraversalNode(node.left,callBack)
      this.postOrderTraversalNode(node.right,callBack)
      callBack(node.key)
    }
  }

  //得到最大值
  BinarySearchTree.prototype.max = function () {
    let node = this.root
    while (node !== null && node.right !== null) {
      node = node.right
    }
    return node.key
  }
  //得到最小值
  BinarySearchTree.prototype.min = function () {
    let node  = this.root
    while (node !== null && node.left !== null) {
      node = node.left
    }
    return node.key
  }

  //搜寻特定key
  BinarySearchTree.prototype.search = function (key) {
    return this.searchNode(this.root,key)
  }
  BinarySearchTree.prototype.searchNode = function (node,key) {
    if (node === null) return false
    if (node.key > key) {
      node = node.left
      //这里必须 ！ return 递归否则调用search会返回undefined
      //return的原因 :因为最后一次调用 searchNode返回的是上一次递归的值，而不是返回的search的值，所以为了确保search有返回值
      //需要每一层都返回，将最后一次的return层层传递上来
      return this.searchNode(node,key)
    } else if (node.key < key) {
      node = node.right
      return this.searchNode(node,key)
    } else {
      return true
    }
  }

  // 删除指定key
  BinarySearchTree.prototype.remove = function (key) {
    let current = this.root
    let parent = null
    let isLeftChild = true

    //1.找到要被删除的节点
    while (current.key != key) {
      parent = current
      if (key < current.key) {
        isLeftChild = true
        current = current.left
      } else {
        isLeftChild = false
        current = current.right
      }
      if (current == null) return false
    }
    //2.删除节点
    //2.1.删除的节点是叶子节点
    if (current.left === null && current.right === null) {
      if (current === this.root) {
        this.root = null
      } else if (isLeftChild) {
        parent.left = null
      } else {
        parent.right = null
      }
    }
    //2.2.删除的节点只有左或右其中一边有子节点
    else if(current.right === null) {
      if (current === this.root) {
        this.root = current.left
      } else if (isLeftChild) {
        parent.left = current.left
      } else {
        parent.right = current.left
      }
    } else if (current.left === null) {
      if (current === this.root) {
        this.root = current.right
      } else if (isLeftChild) {
        parent.left = current.right
      } else {
        parent.right = current.right
      }
    }
    //2.3删除的节点两边都有子节点
    else {
      //前驱 二叉搜索树任意节点的所有左子树中最接近该节点key值得点
      //后继 二叉搜索树任意节点的所有右子树中最接近该节点key值得点
      //获取后继节点
      let successor = this.getSuccessor(current)
      //判断是否是根节点
      if (current === this.root) {
        this.root = successor
      } else if (isLeftChild) {
        parent.left = successor
      } else {
        parent.right = successor
      }
    //让后继的左子树指向，被删除节点的左子树
    successor.left = current.left
    }
  }
  BinarySearchTree.prototype.getSuccessor = function (delNode) {
    let successor = delNode
    let current = delNode.right
    let successorParent = delNode

    while (current != null) {
      successorParent = successor
      successor = current
      current = current.left
    }
    //判断找到的后继是否是delNode的right节点
    if (successor != delNode.right) {
      successorParent.left = successor.right
      successor.right = delNode.right
    }
    return successor
  }

}
```

二叉搜索树的缺陷：某一边的树深度可能非常的深，数据分布不均匀，如果，一直这样下去，它的搜索效率会越来越低，达到接近链表的O(n).这种情况也称`非平衡二叉树` 

为了保证树的平衡性，树的两边节点个数，深度尽可能相等。可以通过平衡二叉树：AVL （严格平衡）和 红黑树（接近平衡）来实现

因为红黑树的插入删除效率要优于AVL树，所以这里对红黑树进行深入学习

### 红黑树

#### 红黑树的规则

- 只有红色黑色两种节点组成
- 根节点是黑色节点
- 叶节点是为null的黑色节点
- 所有红色节点的两个子节点都是黑色（也就是没有相邻的红色节点）
- 任意一个节点到叶节点的路径中黑色节点数目相等

上述规则保证了：从根到叶子的最长路径，不会超过，最短路径的两倍，从而保证了一定的平衡性

为什么不会超过两倍：根据以上特点，可以得出最短路径是全黑色节点，最长路径，因为红色节点不连续所以最长路径是红色黑色交替的节点

#### 节点的插入

插入节点时为了不影响原有的规则，我们通常通过变色和旋转来达到目的

- 变色：

  - 插入新节点时，我们最好让默认颜色为红色，因为如果是黑色会导致这条路径上的黑色节点数和其他路径不符，比较难以调整，而红色则不会
  - 红色的缺点：可能发生红红相连的情况，但这种情况相对于黑色的缺点，较为容易解决

- 旋转：

  - 左旋转：逆时针旋转，原根节点的右孩子变为根结点；原根节点右孩子的左孩子，变为新根节点左孩子的右孩子

  ![数据结构27](G:\笔记\数据结构和算法图片\数据结构27.png)

  - 右旋转：顺时针旋转，原根节点的左孩子变为根结点；原根节点左孩子的右孩子，变为新根节点右孩子的左孩子

  ![数据结构28](G:\笔记\数据结构和算法图片\数据结构28.png)

#### 节点插入时的几种情况

设插入节点为N ；父节点为P； 其祖父节点为G ； P节点的兄弟节点为U（N节点的叔节点）

- 情况一：本身没有节点，插入根节点N,将N变为黑色即可

- 情况二：父节点P为黑色节点，插入红色节点N时，直接插入，不用改变

- 情况三：父节点P ，叔节点U为红色节点，祖父节点G为黑色节点

  - 插入红色节点N ，将父叔节点改为黑色，祖父节点改为红色
  - 可能出现的问题：祖父节点的父节点也为红色
  - 解决方案：继续向上，依次递归调整颜色，如果最后根节点颜色也被改变，则需要再进行旋转或调整颜色

  ![数据结构29](G:\笔记\数据结构和算法图片\数据结构29.png)

- 情况四：父节点P为红色，祖父节点，叔节点为黑色

  - 注：这里的N为左孩子节点
  - 插入红色左孩子节点N，将父节点变为黑色，祖父节点变为红色，之后进行右旋转，将右孩子节点移动到G的左孩子

  ![数据结构30](G:\笔记\数据结构和算法图片\数据结构30.png)

- 情况五：父节点P为红色，祖父节点，叔节点为黑色

  - 注：这里的N为右孩子节点
  - 插入右孩子节点N，将树进行左旋转，之后将N变为黑色，G变为红色，进行右旋转

  ![数据结构31](G:\笔记\数据结构和算法图片\数据结构31.png)

注：情况四和五，插入的节点都在相对于G节点的左子树，如果是右子树，方法基本相同，无非是旋转方向有一点不同

#### 案例演示

注：以下图中的黑色小圈指的是叶子节点null

![数据结构32](G:\笔记\数据结构和算法图片\数据结构32.png)

![数据结构33](G:\笔记\数据结构和算法图片\数据结构33.png)

![数据结构34](G:\笔记\数据结构和算法图片\数据结构34.png)

![数据结构35](G:\笔记\数据结构和算法图片\数据结构35.png)

![数据结构36](G:\笔记\数据结构和算法图片\数据结构36.png)

![数据结构37](G:\笔记\数据结构和算法图片\数据结构37.png)

![数据结构38](G:\笔记\数据结构和算法图片\数据结构38.png)

![数据结构39](G:\笔记\数据结构和算法图片\数据结构39.png)





## 1.10. 图（Graph）

### 图的理解

- 图结构是一种与树结构有些相似的数据结构
- 在数学中有图论的概念，图是图论的主要研究对象，是==由若干顶点及连接两顶点的边所构成的图形==。通常用来描述事物之间的特定关系。顶点代表事物，边表示关系
- 下面为 六个顶点和七条边组成的图
- 顶点V（vertex） 边 E （edge）
- ![数据结构40](G:\笔记\数据结构和算法图片\数据结构40.png)

### 图论的由来

- 欧拉七桥问题：如何不重复不遗漏的走完图中七座桥，并且最后回到起点

![数据结构42](G:\笔记\数据结构和算法图片\数据结构42.png)

可以抽象成如下的图 

欧拉根据该图得出如下结论：

如果想要一笔画出该图形，必须各点为偶顶点（一个顶点连到其他顶点的边数），奇点要么没有，要么在两端

![数据结构43](G:\笔记\数据结构和算法图片\数据结构43.png)

### 图的相关名词

- 相邻顶点：由一条边连接在一起的顶点
- 度：一个顶点相邻顶点的数量
- 路径：顶点v1,v2,v3...vn ，是一个连续的序列
  - 简单路径：要求不包含重复的顶点
  - 回路：第一个顶点和最后一个顶点相同的路径
- 无向图：所有的边都没有方向（可以来可以回）
  - n个顶点无向图，边数最多为n(n-1)/2
- 有向图：所有的边都有方向（单向）
  - 有向图中：入度（到其他顶点的边数）出度（从其他顶点来的边数）
  - 所有顶点的入度之和等于出度之和
- 无权图：边没有携带权重
- 带权图：边有一定的权重（权重可以是任意希望表示的数据，比如距离，花费的时间，票价等等）
- 连通图：图中任意两点都是连通的图称为连通图；如果这个图是一个有向图则它被称为强连通图（需要双向都有路径）
  - n个节点的连通图至少有n-1个边
- 邻接矩阵，邻接表，逆邻接表，深度优先生成树，广度优先生成树等概念由下面两道例题说明

![数据结构44](G:\笔记\数据结构和算法图片\数据结构44.png)

例 1..已知如图所示的有向图，请给出该图的:   
（1）	每个顶点的入/出度；
（2）	邻接矩阵；
（3）	邻接表；
（4）	逆邻接表。

![数据结构45](G:\笔记\数据结构和算法图片\数据结构45.png)

邻接矩阵：每一行代表一个节点，当中的每一个行元素 0代表，不相连，1代表相连   因为这是有向图，所以按照的出度绘制，如果是无向图，则相连就为1，不用考虑入出度

![数据结构46](G:\笔记\数据结构和算法图片\数据结构46.png)



邻接表:按出度绘制                    逆邻接表：按入度绘制

![数据结构47](G:\笔记\数据结构和算法图片\数据结构47.png)

2.已知二维数组表示的图的邻接矩阵如下图所示。试分别画出自顶点1出发进行遍历所得的深度优先生成树和广度优先生成树。

==邻接矩阵广度优先，逐行遍历遍历一行后，根据该行的元素分别遍历下一行；==



==深度优先从第一行开始遇见1则跳转到对应行，直到跳转到结尾后，重复向上递归，遍历剩余部分==

![数据结构48](G:\笔记\数据结构和算法图片\数据结构48.png)

![数据结构49](G:\笔记\数据结构和算法图片\数据结构49.png)

### 图的代码实现

在之后的深度广度遍历中，为了记录顶点是否被访问，我们使用三种颜色反应状态

- 白色：顶点没有被访问
- 灰色：顶点被访问，但没有探索过
- 黑色：顶点被访问且被完全探索

测试用图：

![数据结构50](G:\笔记\数据结构和算法图片\数据结构50.png)

```javascript
//这里的Map与Queue使用的是上文的构造函数


function Graph() {
  //顶点
  this.vertexes = []
  //边 通过创建之前实现的Map函数实例，保存边
  this.edges = new Map()
   //增加顶点方法
  Graph.prototype.addVertex = function (v) {
    this.vertexes.push(v)
    this.edges.set(v,[])
  }
  //增加边方法
  Graph.prototype.addEdge = function (v1,v2) {
    this.edges.get(v1).push(v2)
    this.edges.get(v2).push(v1)
  }
  //toString方法
  Graph.prototype.toString = function () {
    let graphStr = ''
    this.vertexes.forEach(item => {
      graphStr += item + '-> '
      for (const i of this.edges.get(item)) {
        graphStr += i + ' '
      }
      graphStr += '\n'
    })
    return graphStr
  }

  //初始化顶点颜色
  Graph.prototype.initialize = function () {
    const color = {}
    for (const i of this.vertexes) {
      color[i] = 'white'
    }
    return color
  }

  //广度排序
  Graph.prototype.BFS = function (vFist,callback) {
    //1.初始化顶点颜色
    const color = this.initialize()
    //2.创建队列实例 
    const queue = new Queue()
    //3.将第一个顶点加入队列
    queue.enQueue(vFist)
    //3.1 改变该顶点颜色
    color[vFist] = 'gray'
    //4.遍历队列,为空时退出循环
    while (!queue.isEmpty()) {
      //4.1 出队 并得到出队顶点
      const v = queue.deQueue()
      //4.2 得到该顶点的其他邻接顶点数组
      const otherV = this.edges.get(v)
      //4.3 对数组进行遍历
      for (const i of otherV) {
        //4.4 判断顶点的颜色
        if (color[i] === 'white') {
          //4.5 是白色将其加入队列
          queue.enQueue(i)
          //4.6 加入队列的变为灰色 注：因为如果不变色之后其他元素遍历时可能会重复添加同一顶点
          color[i] = 'gray'
        }
      }
      //5.此顶点完全搜索完毕，将顶点变为黑色
      color[v] = 'black'
      //6.将顶点通过回调发送出去
      callback(v)
    }
  }

  //深度排序
  Graph.prototype.DFS = function (vFist,callback) {
    //1.初始化顶点颜色
    const color = this.initialize()
    //2.调用DFSList
    this.DFSList(vFist,color,callback)

  }
  Graph.prototype.DFSList = function (vertex,color,callback) {
    //1.改变顶点颜色
    color[vertex] = 'gray'
    //2.将顶点通过回调发送出去
    callback(vertex)
    //3.得到该顶点的其他邻接顶点数组
    const otherV = this.edges.get(vertex)
    //4.递归遍历其余顶点
    for (const i of otherV) {
      if (color[i] === 'white') {
        this.DFSList(i,color,callback)
      }
    }
    //5.将遍历完毕后的顶点设为黑色
    color[vertex] = 'black'
  }
}
```

